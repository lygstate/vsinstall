From 9b825c83498933848d01240ea560901a66d479db Mon Sep 17 00:00:00 2001
From: Yonggang Luo <luoyonggang@gmail.com>
Date: Tue, 8 May 2018 19:52:14 +0800
Subject: [PATCH] Update using the SP1 version of Header

---
 include/ammintrin.h             | 254 ++++++++++
 include/crtdbg.h                |   3 +-
 include/crtversion.h            |   2 +-
 include/eh.h                    |   1 +
 include/msclr/marshal.h         | 460 ++++++++++++++++++
 include/msclr/marshal_atl.h     | 111 +++++
 include/msclr/marshal_cppstd.h  |  81 ++++
 include/msclr/marshal_windows.h | 112 +++++
 include/omp.h                   | 152 ++++++
 include/pgobootrun.h            |  25 +
 include/srv.h                   | 471 ++++++++++++++++++
 include/wmiatlprov.h            | 824 ++++++++++++++++++++++++++++++++
 include/xutility                |  16 +-
 13 files changed, 2508 insertions(+), 4 deletions(-)
 create mode 100644 include/ammintrin.h
 create mode 100644 include/msclr/marshal.h
 create mode 100644 include/msclr/marshal_atl.h
 create mode 100644 include/msclr/marshal_cppstd.h
 create mode 100644 include/msclr/marshal_windows.h
 create mode 100644 include/omp.h
 create mode 100644 include/pgobootrun.h
 create mode 100644 include/srv.h
 create mode 100644 include/wmiatlprov.h

diff --git a/include/ammintrin.h b/include/ammintrin.h
new file mode 100644
index 0000000..7343344
--- /dev/null
+++ b/include/ammintrin.h
@@ -0,0 +1,254 @@
+/****
+* Copyright (C) 2007-2008 Advanced Micro Devices Inc.  All rights reserved.
+* 
+*  The information and source code contained herein is the exclusive
+*  property of Advanced Micro Devices and may not be disclosed, examined
+*  or reproduced in whole or in part without explicit written authorization
+*  from the company.
+*
+*  ammintrin.h - Definitions for AMD-specific intrinsics
+*
+****/
+
+#pragma once
+#ifndef __midl
+#ifndef _INCLUDED_AMM
+#define _INCLUDED_AMM
+
+#if defined(_M_CEE_PURE)
+  #error ERROR: This file is not supported in the pure mode!
+#else
+
+#if defined __cplusplus
+extern "C" { /* Intrinsics use C name-mangling. */
+#endif
+
+/*
+ * Vector integer comparison control macros
+ */
+
+#define _MM_PCOMCTRL_LT    0
+#define _MM_PCOMCTRL_LE    1
+#define _MM_PCOMCTRL_GT    2
+#define _MM_PCOMCTRL_GE    3
+#define _MM_PCOMCTRL_EQ    4
+#define _MM_PCOMCTRL_NEQ   5
+#define _MM_PCOMCTRL_FALSE 6
+#define _MM_PCOMCTRL_TRUE  7
+
+/*
+ * MACRO functions for vector integer comparisons
+ */
+
+#define _mm_comlt_epu8(v1, v2)      _mm_com_epu8(v1, v2, _MM_PCOMCTRL_LT)
+#define _mm_comle_epu8(v1, v2)      _mm_com_epu8(v1, v2, _MM_PCOMCTRL_LE)
+#define _mm_comgt_epu8(v1, v2)      _mm_com_epu8(v1, v2, _MM_PCOMCTRL_GT)
+#define _mm_comge_epu8(v1, v2)      _mm_com_epu8(v1, v2, _MM_PCOMCTRL_GE)
+#define _mm_comeq_epu8(v1, v2)      _mm_com_epu8(v1, v2, _MM_PCOMCTRL_EQ)
+#define _mm_comneq_epu8(v1, v2)     _mm_com_epu8(v1, v2, _MM_PCOMCTRL_NEQ)
+#define _mm_comfalse_epu8(v1, v2)   _mm_com_epu8(v1, v2, _MM_PCOMCTRL_FALSE)
+#define _mm_comtrue_epu8(v1, v2)    _mm_com_epu8(v1, v2, _MM_PCOMCTRL_TRUE)
+
+#define _mm_comlt_epu16(v1, v2)     _mm_com_epu16(v1, v2, _MM_PCOMCTRL_LT)
+#define _mm_comle_epu16(v1, v2)     _mm_com_epu16(v1, v2, _MM_PCOMCTRL_LE)
+#define _mm_comgt_epu16(v1, v2)     _mm_com_epu16(v1, v2, _MM_PCOMCTRL_GT)
+#define _mm_comge_epu16(v1, v2)     _mm_com_epu16(v1, v2, _MM_PCOMCTRL_GE)
+#define _mm_comeq_epu16(v1, v2)     _mm_com_epu16(v1, v2, _MM_PCOMCTRL_EQ)
+#define _mm_comneq_epu16(v1, v2)    _mm_com_epu16(v1, v2, _MM_PCOMCTRL_NEQ)
+#define _mm_comfalse_epu16(v1, v2)  _mm_com_epu16(v1, v2, _MM_PCOMCTRL_FALSE)
+#define _mm_comtrue_epu16(v1, v2)   _mm_com_epu16(v1, v2, _MM_PCOMCTRL_TRUE)
+
+#define _mm_comlt_epu32(v1, v2)     _mm_com_epu32(v1, v2, _MM_PCOMCTRL_LT)
+#define _mm_comle_epu32(v1, v2)     _mm_com_epu32(v1, v2, _MM_PCOMCTRL_LE)
+#define _mm_comgt_epu32(v1, v2)     _mm_com_epu32(v1, v2, _MM_PCOMCTRL_GT)
+#define _mm_comge_epu32(v1, v2)     _mm_com_epu32(v1, v2, _MM_PCOMCTRL_GE)
+#define _mm_comeq_epu32(v1, v2)     _mm_com_epu32(v1, v2, _MM_PCOMCTRL_EQ)
+#define _mm_comneq_epu32(v1, v2)    _mm_com_epu32(v1, v2, _MM_PCOMCTRL_NEQ)
+#define _mm_comfalse_epu32(v1, v2)  _mm_com_epu32(v1, v2, _MM_PCOMCTRL_FALSE)
+#define _mm_comtrue_epu32(v1, v2)   _mm_com_epu32(v1, v2, _MM_PCOMCTRL_TRUE)
+
+#define _mm_comlt_epu64(v1, v2)     _mm_com_epu64(v1, v2, _MM_PCOMCTRL_LT)
+#define _mm_comle_epu64(v1, v2)     _mm_com_epu64(v1, v2, _MM_PCOMCTRL_LE)
+#define _mm_comgt_epu64(v1, v2)     _mm_com_epu64(v1, v2, _MM_PCOMCTRL_GT)
+#define _mm_comge_epu64(v1, v2)     _mm_com_epu64(v1, v2, _MM_PCOMCTRL_GE)
+#define _mm_comeq_epu64(v1, v2)     _mm_com_epu64(v1, v2, _MM_PCOMCTRL_EQ)
+#define _mm_comneq_epu64(v1, v2)    _mm_com_epu64(v1, v2, _MM_PCOMCTRL_NEQ)
+#define _mm_comfalse_epu64(v1, v2)  _mm_com_epu64(v1, v2, _MM_PCOMCTRL_FALSE)
+#define _mm_comtrue_epu64(v1, v2)   _mm_com_epu64(v1, v2, _MM_PCOMCTRL_TRUE)
+
+#define _mm_comlt_epi8(v1, v2)      _mm_com_epi8(v1, v2, _MM_PCOMCTRL_LT)
+#define _mm_comle_epi8(v1, v2)      _mm_com_epi8(v1, v2, _MM_PCOMCTRL_LE)
+#define _mm_comgt_epi8(v1, v2)      _mm_com_epi8(v1, v2, _MM_PCOMCTRL_GT)
+#define _mm_comge_epi8(v1, v2)      _mm_com_epi8(v1, v2, _MM_PCOMCTRL_GE)
+#define _mm_comeq_epi8(v1, v2)      _mm_com_epi8(v1, v2, _MM_PCOMCTRL_EQ)
+#define _mm_comneq_epi8(v1, v2)     _mm_com_epi8(v1, v2, _MM_PCOMCTRL_NEQ)
+#define _mm_comfalse_epi8(v1, v2)   _mm_com_epi8(v1, v2, _MM_PCOMCTRL_FALSE)
+#define _mm_comtrue_epi8(v1, v2)    _mm_com_epi8(v1, v2, _MM_PCOMCTRL_TRUE)
+
+#define _mm_comlt_epi16(v1, v2)     _mm_com_epi16(v1, v2, _MM_PCOMCTRL_LT)
+#define _mm_comle_epi16(v1, v2)     _mm_com_epi16(v1, v2, _MM_PCOMCTRL_LE)
+#define _mm_comgt_epi16(v1, v2)     _mm_com_epi16(v1, v2, _MM_PCOMCTRL_GT)
+#define _mm_comge_epi16(v1, v2)     _mm_com_epi16(v1, v2, _MM_PCOMCTRL_GE)
+#define _mm_comeq_epi16(v1, v2)     _mm_com_epi16(v1, v2, _MM_PCOMCTRL_EQ)
+#define _mm_comneq_epi16(v1, v2)    _mm_com_epi16(v1, v2, _MM_PCOMCTRL_NEQ)
+#define _mm_comfalse_epi16(v1, v2)  _mm_com_epi16(v1, v2, _MM_PCOMCTRL_FALSE)
+#define _mm_comtrue_epi16(v1, v2)   _mm_com_epi16(v1, v2, _MM_PCOMCTRL_TRUE)
+
+#define _mm_comlt_epi32(v1, v2)     _mm_com_epi32(v1, v2, _MM_PCOMCTRL_LT)
+#define _mm_comle_epi32(v1, v2)     _mm_com_epi32(v1, v2, _MM_PCOMCTRL_LE)
+#define _mm_comgt_epi32(v1, v2)     _mm_com_epi32(v1, v2, _MM_PCOMCTRL_GT)
+#define _mm_comge_epi32(v1, v2)     _mm_com_epi32(v1, v2, _MM_PCOMCTRL_GE)
+#define _mm_comeq_epi32(v1, v2)     _mm_com_epi32(v1, v2, _MM_PCOMCTRL_EQ)
+#define _mm_comneq_epi32(v1, v2)    _mm_com_epi32(v1, v2, _MM_PCOMCTRL_NEQ)
+#define _mm_comfalse_epi32(v1, v2)  _mm_com_epi32(v1, v2, _MM_PCOMCTRL_FALSE)
+#define _mm_comtrue_epi32(v1, v2)   _mm_com_epi32(v1, v2, _MM_PCOMCTRL_TRUE)
+
+#define _mm_comlt_epi64(v1, v2)     _mm_com_epi64(v1, v2, _MM_PCOMCTRL_LT)
+#define _mm_comle_epi64(v1, v2)     _mm_com_epi64(v1, v2, _MM_PCOMCTRL_LE)
+#define _mm_comgt_epi64(v1, v2)     _mm_com_epi64(v1, v2, _MM_PCOMCTRL_GT)
+#define _mm_comge_epi64(v1, v2)     _mm_com_epi64(v1, v2, _MM_PCOMCTRL_GE)
+#define _mm_comeq_epi64(v1, v2)     _mm_com_epi64(v1, v2, _MM_PCOMCTRL_EQ)
+#define _mm_comneq_epi64(v1, v2)    _mm_com_epi64(v1, v2, _MM_PCOMCTRL_NEQ)
+#define _mm_comfalse_epi64(v1, v2)  _mm_com_epi64(v1, v2, _MM_PCOMCTRL_FALSE)
+#define _mm_comtrue_epi64(v1, v2)   _mm_com_epi64(v1, v2, _MM_PCOMCTRL_TRUE)
+
+/* SSE5 intrinsics */
+
+/* Float/double multiply-accumulate */
+__m128 _mm_macc_ps(__m128, __m128, __m128);
+__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
+__m128 _mm_macc_ss(__m128, __m128, __m128);
+__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
+__m128 _mm_maddsub_ps(__m128, __m128, __m128);
+__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
+__m128 _mm_msubadd_ps(__m128, __m128, __m128);
+__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
+__m128 _mm_msub_ps(__m128, __m128, __m128);
+__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
+__m128 _mm_msub_ss(__m128, __m128, __m128);
+__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
+__m128 _mm_nmacc_ps(__m128, __m128, __m128);
+__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
+__m128 _mm_nmacc_ss(__m128, __m128, __m128);
+__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
+__m128 _mm_nmsub_ps(__m128, __m128, __m128);
+__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
+__m128 _mm_nmsub_ss(__m128, __m128, __m128);
+__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);
+
+/* Integer multiply-accumulate */
+__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
+__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
+__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
+__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
+__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
+__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
+__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
+__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
+__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
+__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
+__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
+__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);
+
+/* Horizontal add/subtract */
+__m128i _mm_haddw_epi8(__m128i);
+__m128i _mm_haddd_epi8(__m128i);
+__m128i _mm_haddq_epi8(__m128i);
+__m128i _mm_haddd_epi16(__m128i);
+__m128i _mm_haddq_epi16(__m128i);
+__m128i _mm_haddq_epi32(__m128i);
+__m128i _mm_haddw_epu8(__m128i);
+__m128i _mm_haddd_epu8(__m128i);
+__m128i _mm_haddq_epu8(__m128i);
+__m128i _mm_haddd_epu16(__m128i);
+__m128i _mm_haddq_epu16(__m128i);
+__m128i _mm_haddq_epu32(__m128i);
+__m128i _mm_hsubw_epi8(__m128i);
+__m128i _mm_hsubd_epi16(__m128i);
+__m128i _mm_hsubq_epi32(__m128i);
+
+/* Vector conditional moves */
+__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
+__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);
+
+/* Vector shifts and rotates */
+__m128i _mm_rot_epi8(__m128i, __m128i);
+__m128i _mm_rot_epi16(__m128i, __m128i);
+__m128i _mm_rot_epi32(__m128i, __m128i);
+__m128i _mm_rot_epi64(__m128i, __m128i);
+__m128i _mm_roti_epi8(__m128i, int);
+__m128i _mm_roti_epi16(__m128i, int);
+__m128i _mm_roti_epi32(__m128i, int);
+__m128i _mm_roti_epi64(__m128i, int);
+__m128i _mm_shl_epi8(__m128i, __m128i);
+__m128i _mm_shl_epi16(__m128i, __m128i);
+__m128i _mm_shl_epi32(__m128i, __m128i);
+__m128i _mm_shl_epi64(__m128i, __m128i);
+__m128i _mm_sha_epi8(__m128i, __m128i);
+__m128i _mm_sha_epi16(__m128i, __m128i);
+__m128i _mm_sha_epi32(__m128i, __m128i);
+__m128i _mm_sha_epi64(__m128i, __m128i);
+
+/* Vector integer comparisons */
+
+__m128i _mm_com_epu8(__m128i, __m128i, int);
+__m128i _mm_com_epu16(__m128i, __m128i, int);
+__m128i _mm_com_epu32(__m128i, __m128i, int);
+__m128i _mm_com_epu64(__m128i, __m128i, int);
+__m128i _mm_com_epi8(__m128i, __m128i, int);
+__m128i _mm_com_epi16(__m128i, __m128i, int);
+__m128i _mm_com_epi32(__m128i, __m128i, int);
+__m128i _mm_com_epi64(__m128i, __m128i, int);
+
+/* Precision control */
+
+__m128 _mm_frcz_ps(__m128);
+__m128d _mm_frcz_pd(__m128d);
+__m128 _mm_frcz_ss(__m128, __m128);
+__m128d _mm_frcz_sd(__m128d, __m128d);
+
+/* Control values for permute2 intrinsics */
+#define _MM_PERMUTE2_COPY    0 /* just copy the selected value */
+/* Note that using the constant 1 would have the same effect as 0 */
+#define _MM_PERMUTE2_ZEROIF1 2 /* zero selected value if src3 bit is 1 */
+#define _MM_PERMUTE2_ZEROIF0 3 /* zero selected value if src3 bit is 3 */
+
+/* Permutation */
+__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
+__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);
+
+
+/* YMM versions */
+__m256 _mm256_macc_ps(__m256, __m256, __m256);
+__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
+__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
+__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
+__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
+__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
+__m256 _mm256_msub_ps(__m256, __m256, __m256);
+__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
+__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
+__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
+__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
+__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
+__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
+__m256 _mm256_frcz_ps(__m256);
+__m256d _mm256_frcz_pd(__m256d);
+__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
+__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);
+
+/* LWP intrinsics */
+void __llwpcb(void *);
+void *__slwpcb();
+void __lwpval32(unsigned int, unsigned int, unsigned int);
+void __lwpval64(unsigned __int64, unsigned int, unsigned int);
+unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);
+unsigned char __lwpins64(unsigned __int64, unsigned int, unsigned int);
+
+#if defined __cplusplus
+}; /* End "C" */
+#endif /* __cplusplus */
+
+#endif /* _M_CEE_PURE */
+#endif /* INCLUDED_AMM */
+#endif /* __midl */
diff --git a/include/crtdbg.h b/include/crtdbg.h
index 533e68f..701fba1 100644
--- a/include/crtdbg.h
+++ b/include/crtdbg.h
@@ -7,6 +7,7 @@
 *       Support CRT debugging features.
 *
 *       [Public]
+*
 ****/
 
 #pragma once
@@ -126,7 +127,7 @@ typedef int (__clrcall * _CRT_ALLOC_HOOK_M)(int, void *, size_t, int, long, cons
 
 /*
  * Some bit values for _crtDbgFlag which correspond to frequencies for checking
- * the the heap.
+ * the heap.
  */
 #define _CRTDBG_CHECK_EVERY_16_DF   0x00100000  /* check heap every 16 heap ops */
 #define _CRTDBG_CHECK_EVERY_128_DF  0x00800000  /* check heap every 128 heap ops */
diff --git a/include/crtversion.h b/include/crtversion.h
index 7050efc..7327cd0 100644
--- a/include/crtversion.h
+++ b/include/crtversion.h
@@ -24,7 +24,7 @@
 #endif
 
 #if !defined(_VC_CRT_RBUILD_VERSION)
-#define _VC_CRT_RBUILD_VERSION 01
+#define _VC_CRT_RBUILD_VERSION 325
 #endif
  
  
diff --git a/include/eh.h b/include/eh.h
index 95796c6..2c7f655 100644
--- a/include/eh.h
+++ b/include/eh.h
@@ -7,6 +7,7 @@
 *       User include file for exception handling.
 *
 *       [Public]
+*
 ****/
 
 #pragma once
diff --git a/include/msclr/marshal.h b/include/msclr/marshal.h
new file mode 100644
index 0000000..d4b4f63
--- /dev/null
+++ b/include/msclr/marshal.h
@@ -0,0 +1,460 @@
+/***
+*marshal.h
+*
+*       Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*Purpose:   Marshalling classes
+*
+*       [Public]
+*
+****/
+
+#pragma once
+
+#ifndef _INC_MSCLR_MARSHAL
+#define _INC_MSCLR_MARSHAL
+
+#using <mscorlib.dll>
+#using <system.dll>
+
+#include <sal.h>
+#include <windows.h>
+#include <vcclr.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include <memory>
+
+#pragma comment(lib, "comsupp.lib")
+#pragma comment(lib, "oleaut32.lib")
+
+#pragma warning(push)
+#pragma warning(error : 4996)
+
+namespace msclr{
+	namespace interop{
+
+namespace details
+{
+#define _EXCEPTION_GREATER_THAN_INT_MAX "Size of string exceeds INT_MAX."
+#define _EXCEPTION_NULLPTR "NULLPTR is not supported for this conversion."
+#define _EXCEPTION_MB2WC "Conversion from MultiByte to WideChar failed.  Please check the content of the string and/or locale settings."
+#define _EXCEPTION_WC2MB "Conversion from WideChar to MultiByte failed.  Please check the content of the string and/or locale settings."
+
+	// helper class to allocate/deallocate a buffer with new[]/delete[]
+	template <class T>
+	class char_buffer
+	{
+	public:
+		explicit char_buffer(size_t _size)
+		{
+			_ptr = new T[_size];
+		}
+
+		~char_buffer()
+		{
+			delete [] _ptr;
+		}
+
+		T *get() const
+		{
+			return _ptr;
+		}
+
+		T* release()
+		{
+			T *_ret_value = _ptr;
+			_ptr = NULL;
+			return _ret_value;
+		}
+
+	private:
+		// no copy constructor nor operator=
+		char_buffer(const char_buffer&);
+		char_buffer& operator=(const char_buffer&);
+
+		T *_ptr;
+	};
+
+	inline __checkReturn size_t GetAnsiStringSize(System::String^ _str)
+	{
+		size_t _size = 0;
+		cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_str);
+		
+		_size = ::WideCharToMultiByte(CP_THREAD_ACP, WC_NO_BEST_FIT_CHARS, _pinned_ptr, _str->Length, NULL, 0, NULL,NULL);
+		if (_size == 0 && _str->Length != 0)
+		{
+			throw gcnew System::ArgumentException(_EXCEPTION_WC2MB);
+		}
+		// adding 1 for terminating nul
+		_size+=1;
+		return _size;
+	}
+
+	inline void WriteAnsiString(__out_ecount_full_z(_size) char* _buf, size_t _size, System::String^ _str)
+	{
+		cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_str);
+		
+		//checking for overflow
+		if (_size > INT_MAX)
+		{
+			// this should never happen if _size was returned by GetAnsiStringSize()
+			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
+		}
+		size_t _written = ::WideCharToMultiByte(CP_THREAD_ACP, WC_NO_BEST_FIT_CHARS, _pinned_ptr, _str->Length, _buf, static_cast<int>(_size) ,NULL,NULL);
+		if( _written >= _size || 
+				(_written == 0 && _size != 1)) // allowing empty string
+		{
+			throw gcnew System::ArgumentException(_EXCEPTION_WC2MB);
+		}
+		_buf[_written] = '\0';
+	}
+
+	inline __checkReturn size_t GetUnicodeStringSize(__in_ecount_z(_count+1) const char* _str, size_t _count)
+	{
+		size_t _size = 0;
+		if (_count > INT_MAX)
+		{
+			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
+		}
+		_size = ::MultiByteToWideChar(CP_THREAD_ACP, 0, _str, static_cast<int>(_count), NULL, 0);
+		
+		if (_size == 0 && _count != 0)
+		{
+			throw gcnew System::ArgumentException(_EXCEPTION_MB2WC);
+		}
+		//adding 1 for terminating nul
+		_size+=1;
+		return _size;
+	}
+
+	inline void WriteUnicodeString(__out_ecount_full_z(_size) wchar_t* _dest, size_t _size, __in_bcount(_count)const char* _src, size_t _count)
+	{
+		//checking for overflow
+		if (_size > INT_MAX || _count > INT_MAX)
+		{
+			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
+		}
+
+		size_t _written = ::MultiByteToWideChar(CP_THREAD_ACP, 0, _src, static_cast<int>(_count), _dest, static_cast<int>(_size));
+		if( _written >= _size || 
+				(_written == 0 && _size != 1)) // allowing empty string
+		{
+			throw gcnew System::ArgumentException(_EXCEPTION_MB2WC);
+		}
+		_dest[_written] = L'\0';
+	}
+
+	inline System::String^ InternalAnsiToStringHelper(__in_ecount_z(_count+1)const char* _src, size_t _count)
+	{
+		size_t _size = details::GetUnicodeStringSize(_src, _count);
+		if (_size > INT_MAX || _size <=0 )
+		{
+			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
+		}
+		details::char_buffer<wchar_t> _wchar_buf(_size);
+		if (_wchar_buf.get() == NULL)
+		{
+			throw gcnew System::InsufficientMemoryException();
+		}
+
+		details::WriteUnicodeString(_wchar_buf.get(), _size, _src, _count);
+
+		return gcnew System::String(_wchar_buf.get(), 0, static_cast<int>(_size)-1);
+	}
+
+	inline System::String^ InternalUnicodeToStringHelper(__in_ecount_z(_count+1)const wchar_t* _src, size_t _count)
+	{
+		if (_count > INT_MAX)
+		{
+			throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_GREATER_THAN_INT_MAX);
+		}
+		
+		return gcnew System::String(_src, 0 ,static_cast<int>(_count));
+	}
+} // namespace details
+
+//--------------------------------------------------------------------------------
+// Forward declarations
+//--------------------------------------------------------------------------------
+
+template <class _To_Type, class _From_Type, 
+	 bool _Needs_Context = context_node<_To_Type,_From_Type>::_Needs_Context>
+class error_reporting_helper;
+
+ref class context_node_base;
+
+template<class _To_Type>
+inline _To_Type marshal_as(__in_z const char  _from_object[])
+{
+	const char* _ptr = _from_object;
+	return marshal_as<_To_Type, const char *>(_ptr);
+}
+
+template<class _To_Type>
+inline _To_Type marshal_as(__in_z const wchar_t  _from_object[])
+{
+	const wchar_t* _ptr = _from_object;
+	return marshal_as<_To_Type, const wchar_t*>(_ptr);
+}
+
+template<class _To_Type, class _From_Type>
+ref class context_node;
+
+ref class marshal_context;
+
+template <class _To_Type, class _From_Type>
+inline _To_Type marshal_as(const _From_Type&);
+
+//--------------------------------------------------------------------------------
+// Context-free conversion generic templates
+//--------------------------------------------------------------------------------
+
+template <class _To_Type, class _From_Type>
+class error_reporting_helper<_To_Type, _From_Type, /* _Needs_Context */ false> 
+{
+	public:
+		__declspec(deprecated("This conversion is not supported by the library or the header file needed for this conversion is not included.  Please refer to the documentation on 'How to: Extend the Marshaling Library' for adding your own marshaling method."))
+		static _To_Type marshal_as(const _From_Type& _from_object)
+		{
+			return _This_conversion_is_not_supported;
+		}
+};
+
+template <class _To_Type, class _From_Type>
+class error_reporting_helper<_To_Type, _From_Type, /* _Needs_Context */ true> 
+{
+	public:
+		__declspec(deprecated("This conversion requires a marshal_context.  Please use a marshal_context for this conversion."))
+		static _To_Type marshal_as(const _From_Type& _from_object)
+		{
+			return _This_conversion_requires_a_context;
+		}
+};
+
+template <class _To_Type, class _From_Type>
+inline _To_Type marshal_as(const _From_Type& _from_object)
+{
+	return error_reporting_helper<_To_Type, _From_Type>::marshal_as(_from_object);
+}
+
+//--------------------------------------------------------------------------------
+// Context conversion generic templates
+//--------------------------------------------------------------------------------
+
+ref class context_node_base 
+{
+	public:
+		static const bool _Needs_Context= true;
+};
+
+template<class _To_Type, class _From_Type>
+ref class context_node : public context_node_base
+{
+	public:
+		static const bool _Needs_Context= false;
+};
+
+ref class marshal_context 
+{
+	internal:
+		//The list of objects that need to be cleaned up. Basically all those that have a destructor
+		System::Collections::Generic::LinkedList <Object^> _clean_up_list;
+
+		template<class _To_Type, class _From_Type, bool _Needs_Context>
+		ref class internal_marshaler;
+
+		template<class _To_Type, class _From_Type>
+		ref class internal_marshaler<_To_Type, _From_Type, true>
+		{
+			public:
+			// This is a supported context conversation.
+			// Convert and added it to the list of cleanup
+			static inline _To_Type marshal_as(const _From_Type& _from, System::Collections::Generic::LinkedList<Object^>% _clean_up_list)
+			{
+				typedef context_node<_To_Type, _From_Type> _cn;
+
+				_To_Type _to_object;
+				//Create a context node and assign marshalling result to the 'to' variable
+				_cn^ _obj = gcnew _cn(_to_object, _from);
+				_clean_up_list.AddLast(_obj);
+				return _to_object;
+			};
+		};
+
+		template<class _To_Type, class _From_Type>
+		ref class internal_marshaler<_To_Type, _From_Type, false>
+		{
+			public:
+			// This is not a supported context conversation.
+			// This maybe a context-free conversation or a unsupported converstaion.
+			// Both cases will be handed by the Marshal_as object.
+			static inline _To_Type marshal_as(const _From_Type& _from, System::Collections::Generic::LinkedList<Object^>% _clean_up_list)
+			{
+				(_clean_up_list); // not using this variable intentionally
+				return ::msclr::interop::marshal_as<_To_Type, _From_Type>(_from);
+			};
+		};
+
+	public:
+		template<class _To_Type, class _From_Type>
+		inline _To_Type marshal_as(const _From_Type& _from) 
+		{
+			typedef context_node<_To_Type, _From_Type> _cn;
+			return internal_marshaler<_To_Type, _From_Type, _cn::_Needs_Context>::marshal_as(_from, _clean_up_list);
+		}
+
+		template<class _To_Type, class _From_Type>
+		inline _To_Type marshal_as(_From_Type^ _from) 
+		{
+			typedef context_node<_To_Type, _From_Type^> _cn;
+			return internal_marshaler<_To_Type, _From_Type^, _cn::_Needs_Context>::marshal_as(_from, _clean_up_list);
+		}
+
+		// special case marshal_as() that doesn't fit the usual marshal_as<To,From>() templates
+		template<class _To_Type>
+		inline _To_Type marshal_as(__in_z const char _from[]) 
+		{
+			typedef context_node<_To_Type, const char *> _cn;
+			return internal_marshaler<_To_Type, const char*, _cn::_Needs_Context>::marshal_as(_from, _clean_up_list);
+		}
+
+		template<class _To_Type>
+		inline _To_Type marshal_as(__in_z const wchar_t _from[]) 
+		{
+			typedef context_node<_To_Type, const wchar_t *> _cn;
+			return internal_marshaler<_To_Type, const wchar_t*, _cn::_Needs_Context>::marshal_as(_from, _clean_up_list);
+		}
+
+		template<class _To_Type>
+		inline _To_Type marshal_as(System::IntPtr _from) 
+		{
+			return ::msclr::interop::marshal_as<_To_Type>(_from);
+		}
+
+	marshal_context()
+	{};
+
+	~marshal_context()
+	{
+		for each(Object^ _obj in _clean_up_list)
+			delete _obj;
+	}
+};
+
+//--------------------------------------------------------------------------------
+// Context-free conversions templates specialization for basic types
+//--------------------------------------------------------------------------------
+
+template <>
+inline System::String^ marshal_as(__in_z const char * const & _from_object) 
+{
+	if (!_from_object)
+	{
+		return nullptr;
+	}
+	return details::InternalAnsiToStringHelper(_from_object, strlen(_from_object));
+}
+
+template<>
+inline System::String^ marshal_as(__in_z char * const & _from_object) 
+{
+	return marshal_as<System::String^, const char *>(_from_object);
+}
+
+template <>
+inline System::String^ marshal_as(__in_z const wchar_t* const & _from_object) 
+{
+	if (_from_object == NULL)
+	{
+		return nullptr;
+	}
+	return gcnew System::String(_from_object);
+}
+
+// Note: BSTR and wchar_t* are actually typedef alias.  Therefore, we can not define the
+// conversion BSTR -> System::String^.  BSTR actually will use this function.
+template <>
+inline System::String^ marshal_as(__in_z wchar_t* const& _from_object)
+{
+	return marshal_as<System::String^, const wchar_t *>(_from_object);
+}
+
+//--------------------------------------------------------------------------------
+// Context conversion templates specialization for basic types
+//--------------------------------------------------------------------------------
+
+template<>
+ref class context_node<const char*, System::String^> :
+	public context_node_base
+{
+	private:
+		char* _ptr;
+	public:
+		context_node(__out_z const char*& _to_object, System::String^ _from_object)
+		{
+			_ptr = NULL;
+			if (_from_object == nullptr)
+			{
+				_to_object =nullptr;
+				return;
+			}
+
+			size_t _size = details::GetAnsiStringSize(_from_object);
+
+			details::char_buffer<char> _char_buf(_size);
+			if (_char_buf.get() == NULL)
+			{
+				throw gcnew System::InsufficientMemoryException();
+			}
+
+			details::WriteAnsiString(_char_buf.get(), _size, _from_object);
+
+			_ptr = _char_buf.release();
+			_to_object = _ptr;
+		}
+
+		~context_node()
+		{
+			this->!context_node();
+		}
+
+	protected:
+		!context_node()
+		{
+			delete [] _ptr;
+		}
+};
+
+
+template<>
+ref class context_node<const wchar_t*, System::String^> :
+	public context_node_base
+{
+	private:
+		System::IntPtr _ip;
+	public:
+		context_node(__out_z const wchar_t*& _to_object, System::String^ _from_object) 
+		{
+			_ip = System::Runtime::InteropServices::Marshal::StringToHGlobalUni (_from_object);
+			_to_object = static_cast<wchar_t*>(_ip.ToPointer());
+		}
+
+		~context_node()
+		{
+			this->!context_node();
+		}
+
+	protected:
+		!context_node()
+		{
+			if(_ip != System::IntPtr::Zero)
+				System::Runtime::InteropServices::Marshal::FreeHGlobal(_ip);
+		}
+};
+
+	} //namespace interop
+} //namespace msclr
+
+#pragma warning(pop) // error:4996
+#endif // _INC_MSCLR_MARSHAL
diff --git a/include/msclr/marshal_atl.h b/include/msclr/marshal_atl.h
new file mode 100644
index 0000000..22bc107
--- /dev/null
+++ b/include/msclr/marshal_atl.h
@@ -0,0 +1,111 @@
+/***
+*marshal_atl.h
+*
+*       Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*Purpose:   Marshalling classes
+*
+*       [Public]
+*
+****/
+
+#pragma once
+
+#ifndef _INC_MSCLR_MARSHAL_ATL
+#define _INC_MSCLR_MARSHAL_ATL
+
+#include <atlsafe.h>
+#include <atlbase.h>
+#include <atlstr.h>
+#include <vcclr.h>
+#include <atlcomcli.h> 
+
+#include <msclr\marshal.h>
+
+#using <mscorlib.dll>
+
+namespace msclr{
+	namespace interop{
+
+template <>
+inline System::String^ marshal_as(const CComBSTR& _from_object)
+{
+	if (_from_object.m_str == NULL)
+	{
+		return nullptr;
+	}
+	// Using PtrToStringBSTR here instead of marshal_as<String^, BSTR>() because we want to perserve the embedded NULLs
+	return System::Runtime::InteropServices::Marshal::PtrToStringBSTR(System::IntPtr(_from_object.m_str));
+}
+
+template <>
+inline CComBSTR marshal_as(System::String^ const& _from_object)
+{
+	if (_from_object == nullptr)
+	{
+		return CComBSTR(static_cast<const wchar_t*>(NULL));
+	}
+	if(_from_object->Length == 0)
+	{
+		return CComBSTR(static_cast<const wchar_t*>(L""));
+	}
+
+	cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_from_object);
+	return  CComBSTR( _from_object->Length, static_cast<const wchar_t *>(_pinned_ptr));
+}
+
+template <>
+inline System::String^ marshal_as(const CStringA& _from_obj)
+{
+	return details::InternalAnsiToStringHelper(_from_obj.operator LPCSTR(), _from_obj.GetLength());
+}
+
+template <>
+inline System::String^ marshal_as(const CStringW& _from_obj)
+{
+	// this will perserve the embedded nulls
+	return details::InternalUnicodeToStringHelper(_from_obj.operator LPCWSTR(), _from_obj.GetLength());
+}
+
+template <>
+inline CStringA marshal_as(System::String^ const & _from_obj)
+{
+	if (_from_obj == nullptr)
+	{
+		throw gcnew System::ArgumentNullException(_EXCEPTION_NULLPTR);
+	}
+	CStringA _to_obj;
+	size_t _size = details::GetAnsiStringSize(_from_obj);
+	
+	//checking for overflow
+	if (_size > INT_MAX)
+	{
+		throw gcnew System::ArgumentOutOfRangeException(_EXCEPTION_NULLPTR);
+	}
+
+	int _length = static_cast<int>(_size)-1;
+	
+	//GetBuffer() throws, so we don't need to check for NULL
+	char* _dest_buf = _to_obj.GetBuffer(_length); 
+
+	details::WriteAnsiString(_dest_buf, _size, _from_obj);
+	_to_obj.ReleaseBuffer(_length); // We don't want to include the NULL.  This call will set the length to _length
+
+	return _to_obj;
+}
+
+template <>
+inline CStringW marshal_as(System::String^ const & _from_obj)
+{
+	if (_from_obj == nullptr)
+	{
+		throw gcnew System::ArgumentNullException(_EXCEPTION_NULLPTR);
+	}
+	cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_from_obj);
+	return CStringW(static_cast<const wchar_t *>(_pinned_ptr), _from_obj->Length);
+}
+
+	} //namespace interop
+} //namespace msclr
+
+#endif // _INC_MSCLR_MARSHAL_ATL
diff --git a/include/msclr/marshal_cppstd.h b/include/msclr/marshal_cppstd.h
new file mode 100644
index 0000000..f67888a
--- /dev/null
+++ b/include/msclr/marshal_cppstd.h
@@ -0,0 +1,81 @@
+/***
+*marshal_cppstd.h
+*
+*       Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*Purpose:   Marshalling classes
+*
+*       [Public]
+*
+****/
+
+#pragma once
+
+#ifndef _INC_MSCLR_MARSHAL_CPPSTD
+#define _INC_MSCLR_MARSHAL_CPPSTD
+
+#include <string>
+#include <vector>
+#include <vcclr.h>
+
+#include "marshal.h"
+
+#using <mscorlib.dll>
+
+namespace msclr{
+	namespace interop{
+
+template <>
+inline System::String^ marshal_as(const std::string& _from_obj)
+{
+	return details::InternalAnsiToStringHelper(_from_obj.c_str(), _from_obj.length());
+}
+
+template <>
+inline std::string marshal_as(System::String^ const & _from_obj)
+{
+	if (_from_obj == nullptr)
+	{
+		throw gcnew System::ArgumentNullException(_EXCEPTION_NULLPTR);
+	}
+	std::string _to_obj;
+	size_t _size = details::GetAnsiStringSize(_from_obj);
+	
+	if (_size > 1)
+	{
+		// -1 because resize will automatically +1 for the NULL
+		_to_obj.resize(_size-1);
+		char *_dest_buf = &(_to_obj[0]);
+
+		details::WriteAnsiString(_dest_buf, _size, _from_obj);
+	}
+
+	return _to_obj;
+}
+
+template <>
+inline System::String^ marshal_as(const std::wstring& _from_obj)
+{
+	return details::InternalUnicodeToStringHelper(_from_obj.c_str(), _from_obj.length());
+}
+
+template <>
+inline std::wstring marshal_as(System::String^ const & _from_obj)
+{
+	if(_from_obj != nullptr)
+	{
+		cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_from_obj);
+		std::wstring _to_obj(static_cast<const wchar_t *>(_pinned_ptr), _from_obj->Length);
+
+		return _to_obj;
+	}
+	else
+	{
+		throw gcnew System::ArgumentNullException(_EXCEPTION_NULLPTR);
+	}
+}
+
+	} //namespace interop
+} //namespace msclr
+
+#endif // _INC_MSCLR_MARSHAL_CPPSTD
diff --git a/include/msclr/marshal_windows.h b/include/msclr/marshal_windows.h
new file mode 100644
index 0000000..36f9d1d
--- /dev/null
+++ b/include/msclr/marshal_windows.h
@@ -0,0 +1,112 @@
+/***
+*marshal_windows.h
+*
+*       Copyright (c) Microsoft Corporation. All rights reserved.
+*
+*Purpose:   Marshalling classes
+*
+*       [Public]
+*
+****/
+
+#pragma once
+
+#ifndef _INC_MSCLR_MARSHAL_WINDOWS
+#define _INC_MSCLR_MARSHAL_WINDOWS
+
+#include <msclr\marshal.h>
+#include <windows.h>
+#include <comutil.h> 
+
+#using <mscorlib.dll>
+
+namespace msclr{
+	namespace interop{
+
+//--------------------------------------------------------------------------------
+// Context-free conversions templates specialization for windows types
+//--------------------------------------------------------------------------------
+
+//
+// for BSTR -> System::String^, please see wchar_t* -> String^ in marshal.h
+//
+
+template <>
+inline System::String^ marshal_as(const _bstr_t & _from_object)
+{
+	BSTR _bstr = _from_object.copy(false);
+	if (_bstr == NULL)
+	{
+		return nullptr;
+	}
+	// Using PtrToStringBSTR here instead of marshal_as<String^, BSTR>() because we want to perserve the embedded NULLs
+	return System::Runtime::InteropServices::Marshal::PtrToStringBSTR(System::IntPtr(_bstr));
+}
+
+template <>
+inline _bstr_t marshal_as(System::String^ const & _from_object)
+{
+	if (_from_object == nullptr)
+	{
+		return _bstr_t(static_cast<BSTR>(NULL));
+	}
+
+	_bstr_t _ret_bstr_t;
+	cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_from_object);
+	_ret_bstr_t.Attach(::SysAllocStringLen(_pinned_ptr, _from_object->Length));
+	if (!_ret_bstr_t)
+	{
+		throw gcnew System::InsufficientMemoryException();
+	}
+	return _ret_bstr_t;
+}
+
+template <>
+inline System::IntPtr marshal_as(const HANDLE& _from_object)
+{
+	return System::IntPtr(_from_object);
+}
+
+template <class _To_Type>
+inline _To_Type marshal_as(System::IntPtr _from_object);
+
+template <>
+inline HANDLE marshal_as(System::IntPtr _from_object)
+{
+	return static_cast<HANDLE>(_from_object.ToPointer());
+}
+
+//--------------------------------------------------------------------------------
+// Context conversion templates specialization for windows types
+//--------------------------------------------------------------------------------
+
+template<>
+ref class context_node<BSTR, System::String^> :
+	public context_node_base
+{
+	private:
+		System::IntPtr _ip;
+	public:
+		context_node(BSTR& _to_object, System::String^ from) 
+		{
+			_ip = System::Runtime::InteropServices::Marshal::StringToBSTR (from);
+			_to_object = static_cast<BSTR>(_ip.ToPointer());
+		}
+
+		~context_node()
+		{
+			this->!context_node();
+		}
+
+	protected:
+		!context_node()
+		{
+			if(_ip != System::IntPtr::Zero)
+				System::Runtime::InteropServices::Marshal::FreeBSTR(_ip);
+		}
+};
+
+	} //namespace interop
+} //namespace msclr
+
+#endif // _INC_MSCLR_MARSHAL_WINDOWS
diff --git a/include/omp.h b/include/omp.h
new file mode 100644
index 0000000..c5e5c86
--- /dev/null
+++ b/include/omp.h
@@ -0,0 +1,152 @@
+//-----------------------------------------------------------------------------
+// OpenMP runtime support library for Visual C++
+// Copyright (C) Microsoft Corporation.  All rights reserved.
+//-----------------------------------------------------------------------------
+
+// OpenMP C/C++ Version 2.0 March 2002
+
+#pragma once
+
+#if defined(__cplusplus)
+extern "C" {
+#endif
+
+#define _OMPAPI     __cdecl
+
+#if !defined(_OMP_LOCK_T)
+#define _OMP_LOCK_T
+typedef void * omp_lock_t;
+#endif
+
+#if !defined(_OMP_NEST_LOCK_T)
+#define _OMP_NEST_LOCK_T
+typedef void * omp_nest_lock_t;
+#endif
+
+#if !defined(_OPENMP)
+
+#if defined(_DEBUG)
+    #pragma comment(lib, "vcompd")
+#else   // _DEBUG
+    #pragma comment(lib, "vcomp")
+#endif  // _DEBUG
+
+#endif // _OPENMP
+
+#if !defined(_OMPIMP)
+#define _OMPIMP     __declspec(dllimport)
+#endif
+
+_OMPIMP void _OMPAPI
+omp_set_num_threads(
+    int _Num_threads
+    );
+
+_OMPIMP int _OMPAPI
+omp_get_num_threads(
+    void
+    );
+
+_OMPIMP int _OMPAPI
+omp_get_max_threads(
+    void
+    );
+
+_OMPIMP int _OMPAPI
+omp_get_thread_num(
+    void
+    );
+
+_OMPIMP int _OMPAPI
+omp_get_num_procs(
+    void
+    );
+
+_OMPIMP void _OMPAPI
+omp_set_dynamic(
+    int _Dynamic_threads
+    );
+
+_OMPIMP int _OMPAPI
+omp_get_dynamic(
+    void
+    );
+
+_OMPIMP int _OMPAPI
+omp_in_parallel(
+    void
+    );
+
+_OMPIMP void _OMPAPI
+omp_set_nested(
+    int _Nested
+    );
+
+_OMPIMP int _OMPAPI
+omp_get_nested(
+    void
+    );
+
+_OMPIMP void _OMPAPI
+omp_init_lock(
+    omp_lock_t * _Lock
+    );
+
+_OMPIMP void _OMPAPI
+omp_destroy_lock(
+    omp_lock_t * _Lock
+    );
+
+_OMPIMP void _OMPAPI
+omp_set_lock(
+    omp_lock_t * _Lock
+    );
+
+_OMPIMP void _OMPAPI
+omp_unset_lock(
+    omp_lock_t * _Lock
+    );
+
+_OMPIMP int _OMPAPI
+omp_test_lock(
+    omp_lock_t * _Lock
+    );
+
+_OMPIMP void _OMPAPI
+omp_init_nest_lock(
+    omp_nest_lock_t * _Lock
+    );
+
+_OMPIMP void _OMPAPI
+omp_destroy_nest_lock(
+    omp_nest_lock_t * _Lock
+    );
+
+_OMPIMP void _OMPAPI
+omp_set_nest_lock(
+    omp_nest_lock_t * _Lock
+    );
+
+_OMPIMP void _OMPAPI
+omp_unset_nest_lock(
+    omp_nest_lock_t * _Lock
+    );
+
+_OMPIMP int _OMPAPI
+omp_test_nest_lock(
+    omp_nest_lock_t * _Lock
+    );
+
+_OMPIMP double _OMPAPI
+omp_get_wtime(
+    void
+    );
+
+_OMPIMP double _OMPAPI
+omp_get_wtick(
+    void
+    );
+
+#if defined(__cplusplus)
+}
+#endif
diff --git a/include/pgobootrun.h b/include/pgobootrun.h
new file mode 100644
index 0000000..c2be6ff
--- /dev/null
+++ b/include/pgobootrun.h
@@ -0,0 +1,25 @@
+#if defined(_WCHAR_T_DEFINED)
+typedef void (__cdecl *POGOAUTOSWEEPPROCW)(const wchar_t *);
+#else
+typedef void (__cdecl *POGOAUTOSWEEPPROCW)(const unsigned short *);
+#endif
+typedef void (__cdecl *POGOAUTOSWEEPPROCA)(const char *);
+
+#ifdef __cplusplus
+extern "C"
+#else
+extern
+#endif
+POGOAUTOSWEEPPROCW PogoAutoSweepW;
+#ifdef __cplusplus
+extern "C"
+#else
+extern
+#endif
+POGOAUTOSWEEPPROCA PogoAutoSweepA;
+
+#ifdef UNICODE
+#define PgoAutoSweep PogoAutoSweepW
+#else
+#define PgoAutoSweep PogoAutoSweepA
+#endif
diff --git a/include/srv.h b/include/srv.h
new file mode 100644
index 0000000..c53a29c
--- /dev/null
+++ b/include/srv.h
@@ -0,0 +1,471 @@
+//------------------------------------------------------------
+// Open Data Services header file: srv.h
+// Copyright (c) Microsoft Corporation. All rights reserved.
+//
+
+// Avoid double inclusion
+#ifndef _ODS_SRV_H_
+#define _ODS_SRV_H_
+
+#ifndef COMPILE_FOR_CLR
+#include "windows.h"
+#endif
+
+// ODS uses pack(4) on all CPU types
+#pragma pack(4)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+// define model
+#if !defined( FAR )
+#define FAR far
+#endif
+
+//------------------------------------------------------------
+// Formats of data types
+#if !defined(DBTYPEDEFS) // Do not conflict with DBLIB definitions
+#if !defined(MAXNUMERICLEN) // Do not conflict with ODBC definitions
+
+#define DBTYPEDEFS
+
+typedef unsigned char DBBOOL;
+typedef unsigned char DBBYTE;
+typedef unsigned char DBTINYINT;
+typedef short DBSMALLINT;
+typedef unsigned short DBUSMALLINT;
+typedef long DBINT;
+typedef char DBCHAR;
+typedef unsigned char DBBINARY;
+typedef unsigned char DBBIT;
+typedef double DBFLT8;
+
+typedef struct srv_datetime 
+{	// Format for SRVDATETIME
+    long dtdays;            // number of days since 1/1/1900
+    unsigned long dttime;   // number 300th second since mid
+} DBDATETIME;				
+
+typedef struct srv_money 
+{		// Format for SRVMONEY
+    long mnyhigh;
+    unsigned long mnylow;
+} DBMONEY;
+
+typedef float DBFLT4;
+typedef long DBMONEY4;
+
+typedef struct dbdatetime4 
+{	// Format for SRVDATETIM4
+    unsigned short numdays; // number of days since 1/1/1900
+    unsigned short nummins; // number of minutes sicne midnight
+} DBDATETIM4;
+
+#define MAXNUMERICLEN	16
+typedef struct dbnumeric	
+{	// Format for SRVNUMERIC,SRVNUMERICN,SRVDECIMAL,SRVDECIMALN
+	BYTE precision;
+	BYTE scale;
+	BYTE sign;
+	BYTE val[MAXNUMERICLEN];
+} DBNUMERIC;
+typedef DBNUMERIC DBDECIMAL;
+
+#endif  // #if !defined(MAXNUMERICLEN)
+#endif  // #if !defined( DBTYPEDEFS )
+
+//------------------------------------------------------------
+// Constants used by APIs
+
+// Type Tokens
+#define SRV_TDS_NULL           (BYTE) 0x1f
+#define SRV_TDS_TEXT           (BYTE) 0x23
+#define SRV_TDS_GUID           (BYTE) 0x24
+#define SRV_TDS_VARBINARY      (BYTE) 0x25
+#define SRV_TDS_INTN           (BYTE) 0x26
+#define SRV_TDS_VARCHAR        (BYTE) 0x27
+#define SRV_TDS_BINARY         (BYTE) 0x2d
+#define SRV_TDS_IMAGE          (BYTE) 0x22
+#define SRV_TDS_CHAR           (BYTE) 0x2f
+#define SRV_TDS_INT1           (BYTE) 0x30
+#define SRV_TDS_BIT            (BYTE) 0x32
+#define SRV_TDS_INT2           (BYTE) 0x34
+#define SRV_TDS_DECIMAL        (BYTE) 0x37
+#define SRV_TDS_INT4           (BYTE) 0x38
+#define SRV_TDS_DATETIM4       (BYTE) 0x3a
+#define SRV_TDS_FLT4           (BYTE) 0x3b
+#define SRV_TDS_MONEY          (BYTE) 0x3c
+#define SRV_TDS_DATETIME       (BYTE) 0x3d
+#define SRV_TDS_FLT8           (BYTE) 0x3e
+#define SRV_TDS_NUMERIC        (BYTE) 0x3f
+#define SRV_TDS_SSVARIANT      (BYTE) 0x62
+#define SRV_TDS_NTEXT		   (BYTE) 0x63
+#define SRV_TDS_BITN		   (BYTE) 0x68
+#define SRV_TDS_DECIMALN       (BYTE) 0x6a
+#define SRV_TDS_NUMERICN       (BYTE) 0x6c
+#define SRV_TDS_FLTN           (BYTE) 0x6d
+#define SRV_TDS_MONEYN         (BYTE) 0x6e
+#define SRV_TDS_DATETIMN       (BYTE) 0x6f
+#define SRV_TDS_MONEY4         (BYTE) 0x7a
+#define SRV_TDS_INT8           (BYTE) 0x7f
+#define SRV_TDS_BIGVARBINARY   (BYTE) 0xA5
+#define SRV_TDS_BIGVARCHAR     (BYTE) 0xA7
+#define SRV_TDS_BIGBINARY      (BYTE) 0xAD
+#define SRV_TDS_BIGCHAR        (BYTE) 0xAF
+#define SRV_TDS_NVARCHAR	   (BYTE) 0xe7
+#define SRV_TDS_NCHAR		   (BYTE) 0xef
+
+// Datatypes
+// Also: values of symbol parameter to srv_symbol when type = SRV_DATATYPE
+#define SRVNULL        SRV_TDS_NULL
+#define SRVTEXT        SRV_TDS_TEXT
+#define SRVGUID        SRV_TDS_GUID
+#define SRVVARBINARY   SRV_TDS_VARBINARY
+#define SRVINTN        SRV_TDS_INTN
+#define SRVVARCHAR     SRV_TDS_VARCHAR
+#define SRVBINARY      SRV_TDS_BINARY
+#define SRVIMAGE       SRV_TDS_IMAGE
+#define SRVCHAR        SRV_TDS_CHAR
+#define SRVINT1        SRV_TDS_INT1
+#define SRVBIT         SRV_TDS_BIT
+#define SRVINT2        SRV_TDS_INT2
+#define SRVDECIMAL	   SRV_TDS_DECIMAL
+#define SRVINT4        SRV_TDS_INT4
+#define SRVDATETIM4    SRV_TDS_DATETIM4
+#define SRVFLT4        SRV_TDS_FLT4    
+#define SRVMONEY       SRV_TDS_MONEY
+#define SRVDATETIME    SRV_TDS_DATETIME
+#define SRVFLT8        SRV_TDS_FLT8
+#define SRVNUMERIC	   SRV_TDS_NUMERIC
+#define SRVSSVARIANT   SRV_TDS_SSVARIANT
+#define SRVNTEXT	   SRV_TDS_NTEXT
+#define SRVBITN		   SRV_TDS_BITN
+#define SRVDECIMALN	   SRV_TDS_DECIMALN
+#define SRVNUMERICN	   SRV_TDS_NUMERICN
+#define SRVFLTN        SRV_TDS_FLTN
+#define SRVMONEYN      SRV_TDS_MONEYN
+#define SRVDATETIMN    SRV_TDS_DATETIMN
+#define SRVMONEY4      SRV_TDS_MONEY4
+#define SRVINT8        SRV_TDS_INT8  
+#define SRVBIGVARBINARY SRV_TDS_BIGVARBINARY
+#define SRVBIGVARCHAR  SRV_TDS_BIGVARCHAR
+#define SRVBIGBINARY   SRV_TDS_BIGBINARY
+#define SRVBIGCHAR     SRV_TDS_BIGCHAR
+#define SRVNVARCHAR	   SRV_TDS_NVARCHAR
+#define SRVNCHAR	   SRV_TDS_NCHAR
+
+// values for srv_symbol type parameter
+#define SRV_ERROR      0
+#define SRV_DONE       1
+#define SRV_DATATYPE   2
+#define SRV_EVENT      4
+
+// values for srv_symbol symbol parameter, when type = SRV_ERROR
+#define SRV_ENO_OS_ERR     0
+#define SRV_INFO           1
+#define SRV_FATAL_PROCESS  10
+#define SRV_FATAL_SERVER   19
+
+// Types of server events
+// Also: values for srv_symbol symbol parameter, when type = SRV_EVENT
+#define SRV_CONTINUE       0
+#define SRV_LANGUAGE       1
+#define SRV_CONNECT        2
+#define SRV_RPC            3
+#define SRV_RESTART        4
+#define SRV_DISCONNECT     5
+#define SRV_ATTENTION      6
+#define SRV_SLEEP          7
+#define SRV_START          8
+#define SRV_STOP           9
+#define SRV_EXIT           10
+#define SRV_CANCEL         11
+#define SRV_SETUP          12
+#define SRV_CLOSE          13
+#define SRV_PRACK          14
+#define SRV_PRERROR        15
+#define SRV_ATTENTION_ACK  16
+#define SRV_CONNECT_V7	   16	// TDS type for TDS 7 clients.  Overloaded with SRV_ATTENTION_ACK
+#define SRV_SKIP		   17
+#define SRV_TRANSMGR	   18
+#define SRV_PRELOGIN	   19
+#define SRV_OLEDB	       20
+#define SRV_INTERNAL_HANDLER 99
+#define SRV_PROGRAMMER_DEFINED  100
+
+// values for srv_sfield field parameter
+#define SRV_SERVERNAME          0
+#define SRV_VERSION             6
+
+// Length to indicate string is null terminated
+#define SRV_NULLTERM   -1
+
+// values of msgtype parameter to srv_sendmsg
+#define SRV_MSG_INFO    1
+#define SRV_MSG_ERROR   2
+
+// values of status parameter to srv_senddone
+// Also: values for symbol parameters to srv_symbol when type = SRV_DONE
+#define SRV_DONE_FINAL			(USHORT) 0x0000
+#define SRV_DONE_MORE			(USHORT) 0x0001
+#define SRV_DONE_ERROR			(USHORT) 0x0002
+#define SRV_DONE_COUNT			(USHORT) 0x0010
+#define SRV_DONE_RPC_IN_BATCH   (USHORT) 0x0080
+
+// return values of srv_paramstatus
+#define SRV_PARAMRETURN		0x0001
+#define SRV_PARAMDEFAULT    0x0002
+#define SRV_PARAMSORTORDER	0x0004
+
+// return values of srv_rpcoptions
+#define SRV_RECOMPILE		0x0001
+#define SRV_NOMETADATA		0x0002
+
+// values of field parameter to srv_pfield
+//#define SRV_LANGUAGE 1   already defined above
+//#define SRV_EVENT    4   already defined above
+#define SRV_SPID				10
+#define SRV_NETSPID				11
+#define SRV_TYPE				12
+#define SRV_STATUS				13
+#define SRV_RMTSERVER			14
+#define SRV_HOST				15
+#define SRV_USER				16
+#define SRV_PWD					17
+#define SRV_CPID				18
+#define SRV_APPLNAME			19
+#define SRV_TDS					20
+#define SRV_CLIB				21
+#define SRV_LIBVERS				22
+#define SRV_ROWSENT				23
+#define SRV_BCPFLAG				24
+#define SRV_NATLANG				25
+#define SRV_PIPEHANDLE			26
+#define SRV_NETWORK_MODULE	    27
+#define SRV_NETWORK_VERSION		28
+#define SRV_NETWORK_CONNECTION	29
+#define SRV_LSECURE				30
+#define SRV_SAXP				31
+#define SRV_UNICODE_USER		33
+#define SRV_UNICODE_PWD			35
+#define SRV_SPROC_CODEPAGE      36
+#define SRV_MSGLCID				37
+#define SRV_INSTANCENAME		38
+#define SRV_HASHPWD				39
+#define SRV_UNICODE_CURRENTLOGIN 40
+
+// return value of SRV_TDSVERSION macro
+#define SRV_TDS_NONE   0
+#define SRV_TDS_2_0    1
+#define SRV_TDS_3_4    2
+#define SRV_TDS_4_2    3
+#define SRV_TDS_6_0    4
+#define SRV_TDS_7_0    5
+
+// Return values from APIs
+typedef int SRVRETCODE;        // SUCCEED or FAIL
+#ifndef ODBCVER
+typedef int RETCODE;
+#endif
+
+#if !defined( SUCCEED )
+#define SUCCEED     1   // Successful return value
+#endif
+
+#if !defined( FAIL )
+#define FAIL        0   // Unsuccessful return value
+#endif
+
+#define SRV_DUPLICATE_HANDLER	2	// additional return value for srv_pre/post_handle
+
+#ifndef COMPILE_FOR_CLR
+//------------------------------------------------
+//PreDeclare structures
+//
+struct srv_server;
+typedef struct srv_server SRV_SERVER;
+
+struct srv_config;
+typedef struct srv_config SRV_CONFIG;
+
+struct CXPData;
+typedef struct CXPData SRV_PROC;
+
+
+//------------------------------------------------
+//------------------------------------------------
+// ODS MACROs & APIs
+
+// Describing and sending a result set
+int __cdecl srv_describe(SRV_PROC*,int,char*,int,long int,long int,long int,long int,void*);
+int __cdecl srv_setutype(SRV_PROC* srvproc,int column,long int usertype);
+int __cdecl srv_setcoldata(SRV_PROC* srvproc,int column,void* data);
+int __cdecl srv_setcollen( SRV_PROC* srvproc,int column,int len);
+int __cdecl srv_sendrow(SRV_PROC* srvproc );
+int __cdecl srv_senddone(SRV_PROC* srvproc,USHORT status,USHORT curcmd,long int count);
+
+// Dealing with Extended Procedure parameters
+int __cdecl srv_rpcparams(SRV_PROC*);
+int __cdecl srv_paraminfo(SRV_PROC*,int,BYTE*,ULONG*,ULONG*,BYTE*,BOOL*);
+int __cdecl srv_paramsetoutput(SRV_PROC*,int,BYTE*,ULONG,BOOL);
+
+void* __cdecl srv_paramdata(SRV_PROC*,int);
+int __cdecl srv_paramlen(SRV_PROC*,int);
+int __cdecl srv_parammaxlen(SRV_PROC*,int);
+int __cdecl srv_paramtype(SRV_PROC*,int);
+int __cdecl srv_paramset(SRV_PROC*,int,void*,int);
+
+char* __cdecl srv_paramname(SRV_PROC*,int,int*);
+int __cdecl srv_paramnumber(SRV_PROC*,char*,int);
+
+//--------------------------------------------------------------
+//--------------------------------------------------------------
+// The rest of these APIs are still supported, in SQL Server 7.0,
+// but may not be supported after SQL Server 7.0
+
+// MACROs
+#define SRV_GETSERVER(a)		srv_getserver	  ( a )
+#define SRV_GOT_ATTENTION(a)	srv_got_attention ( a )
+#define	SRV_TDSVERSION(a)		srv_tdsversion	  ( a )
+
+SRV_SERVER* __cdecl srv_getserver( SRV_PROC   * srvproc );
+BOOL __cdecl srv_got_attention( SRV_PROC * srvproc );
+
+// Memory
+void* __cdecl srv_alloc(long int ulSize);
+int __cdecl srv_bmove(void* from,void* to,long int count);
+int __cdecl srv_bzero( void  * location,long int count);
+int __cdecl srv_free( void * ptr );
+
+
+int __cdecl srv_convert(SRV_PROC*,int,void*,long int,int,void*,long int);
+
+void* __cdecl srv_getuserdata( SRV_PROC * srvproc );
+
+int __cdecl srv_getbindtoken(SRV_PROC * srvproc,char* token_buf);
+
+int __cdecl srv_getdtcxact(SRV_PROC * srvproc,void ** ppv);
+
+typedef int (* EventHandler)(void *);
+
+int __cdecl srv_impersonate_client( SRV_PROC * srvproc );
+
+long __cdecl srv_langcpy(SRV_PROC *	srvproc,long start,long nbytes,char* buffer);
+long __cdecl srv_langlen( SRV_PROC * srvproc );
+void* __cdecl srv_langptr( SRV_PROC *srvproc );
+
+int
+     __cdecl srv_log( SRV_SERVER * server,
+					BOOL	     datestamp,
+					char     * msg,
+					int 	     msglen );
+
+int __cdecl srv_paramstatus(SRV_PROC*,int);
+
+void* __cdecl srv_pfieldex( SRV_PROC * srvproc,int	field,int	* len );
+
+char* __cdecl srv_pfield( SRV_PROC * srvproc,int	      field,int	    * len );
+
+int __cdecl srv_returnval( SRV_PROC * srvproc,
+						  char   * valuename,
+						  int		 len,
+						  BYTE		 status,
+						  long int 	 type,
+						  long int 	 maxlen,
+						  long int 	 datalen,
+						  void	   * value );
+
+int __cdecl srv_revert_to_self( SRV_PROC * srvproc );
+
+char* __cdecl srv_rpcdb(SRV_PROC* srvproc,int* len );
+char* __cdecl srv_rpcname(SRV_PROC * srvproc,int* len );
+int __cdecl srv_rpcnumber( SRV_PROC * srvproc );
+USHORT __cdecl srv_rpcoptions( SRV_PROC * srvproc );
+char* __cdecl srv_rpcowner( SRV_PROC * srvproc,int	  * len );
+
+int __cdecl srv_wsendmsg(	SRV_PROC	* srvproc,
+						long int	msgnum, 
+						BYTE		msgclass, 
+						WCHAR		* message,    // message text 
+						int			msglen);	   // length of message text
+
+int
+     __cdecl srv_sendmsg( SRV_PROC  * srvproc,
+						int	        msgtype,
+						long int	    msgnum,
+						BYTE   msgclass,
+						BYTE   state,
+						char	  * rpcname,
+						int	        rpcnamelen,
+						USHORT linenum,
+						char	  * message,
+						int	        msglen );
+
+int __cdecl srv_sendstatus( SRV_PROC * srvproc,long int	  status );
+
+
+int __cdecl srv_setuserdata(SRV_PROC* srvproc,void* ptr);
+
+
+char* __cdecl srv_sfield( SRV_SERVER * server,int field,int* len);
+
+char* __cdecl srv_symbol(int	type,int symbol,int* len);
+
+int __cdecl srv_tdsversion(SRV_PROC* srvproc);
+
+BOOL __cdecl srv_willconvert(int srctype,int desttype );
+
+int __cdecl srv_terminatethread( SRV_PROC * srvproc );
+
+int __cdecl srv_sendstatistics( SRV_PROC * srvproc );
+
+int __cdecl srv_clearstatistics( SRV_PROC * srvproc );
+
+int __cdecl srv_message_handler( SRV_PROC * srvproc, 
+								int        errornum, 
+								BYTE       severity,
+								BYTE       state, 
+								int        oserrnum, 
+								char     * errtext, 
+								int        errtextlen, 
+								char     * oserrtext, 
+								int        oserrtextlen );
+
+int __cdecl srv_pre_handle( SRV_SERVER * server,
+						    SRV_PROC   * srvproc,
+						    long int event,
+						    EventHandler handler,
+						    BOOL         remove );
+int __cdecl srv_post_handle( SRV_SERVER * server,
+							 SRV_PROC   * srvproc,
+							 long int        event,
+							 EventHandler handler,
+							 BOOL         remove );
+
+int __cdecl srv_IgnoreAnsiToOem( SRV_PROC * srvproc,BOOL bTF);
+
+#endif // #ifndef COMPILE_FOR_CLR
+
+#ifdef __cplusplus
+}
+#endif
+
+#pragma pack()
+
+#define SS_MAJOR_VERSION    7
+#define SS_MINOR_VERSION    00
+#define SS_LEVEL_VERSION    0000
+#define SS_MINIMUM_VERSION  "7.00.00.0000"
+#define ODS_VERSION			((SS_MAJOR_VERSION << 24)  | (SS_MINOR_VERSION << 16))
+
+#endif //_ODS_SRV_H_
+
+//////////////////////////////////////////////////////////////////
+// Suggested implementation of __GetXpVersion
+//
+//__declspec(dllexport) ULONG __GetXpVersion() 
+//	{
+//	return ODS_VERSION;
+//	}
+//////////////////////////////////////////////////////////////////
diff --git a/include/wmiatlprov.h b/include/wmiatlprov.h
new file mode 100644
index 0000000..2f1c65e
--- /dev/null
+++ b/include/wmiatlprov.h
@@ -0,0 +1,824 @@
+// This is a part of the Active Template Library.
+// Copyright (C) 1996-2000 Microsoft Corporation
+// All rights reserved.
+//
+// This source code is only intended as a supplement to the
+// Active Template Library Reference and related
+// electronic documentation provided with the library.
+// See these sources for detailed information regarding the
+// Active Template Library product.
+
+#ifndef __ATLWMIPROV_H__
+#define __ATLWMIPROV_H__
+
+#pragma once
+
+#ifndef __cplusplus
+    #error requires C++ compilation (use a .cpp suffix)
+#endif
+
+#ifndef __wbemprov_h__
+    #include <wbemprov.h>
+#endif
+
+#ifndef __wmiutils_h__
+    #include <wmiutils.h>
+#endif
+
+namespace ATL
+{
+
+class ATL_NO_VTABLE IWbemInstProviderImpl : public IWbemServices,
+                                            public IWbemProviderInit
+    
+{
+public:
+
+    //IWbemServices  
+
+    HRESULT STDMETHODCALLTYPE OpenNamespace( 
+        /* [in] */ const BSTR Namespace,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) {return WBEM_E_NOT_SUPPORTED;};
+    
+/*?*/HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
+        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) {return WBEM_E_NOT_SUPPORTED;};
+        
+/*?*/HRESULT STDMETHODCALLTYPE QueryObjectSink( 
+        /* [in] */ long lFlags,
+        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE GetObject( 
+        /* [in] */ const BSTR ObjectPath,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
+    
+    
+    HRESULT STDMETHODCALLTYPE PutClass( 
+        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE PutClassAsync( 
+        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE DeleteClass( 
+        /* [in] */ const BSTR Class,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
+        /* [in] */ const BSTR Class,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
+        /* [in] */ const BSTR Superclass,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
+        /* [in] */ const BSTR Superclass,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE PutInstance( 
+        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
+    
+    
+    HRESULT STDMETHODCALLTYPE DeleteInstance( 
+        /* [in] */ const BSTR ObjectPath,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
+    
+    
+    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
+        /* [in] */ const BSTR Class,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
+    
+    
+    HRESULT STDMETHODCALLTYPE ExecQuery( 
+        /* [in] */ const BSTR QueryLanguage,
+        /* [in] */ const BSTR Query,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
+        /* [in] */ const BSTR QueryLanguage,
+        /* [in] */ const BSTR Query,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
+        /* [in] */ const BSTR QueryLanguage,
+        /* [in] */ const BSTR Query,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE ExecMethod( 
+        /* [in] */ const BSTR strObjectPath,
+        /* [in] */ const BSTR strMethodName,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
+        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
+    
+    HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
+        /* [in] */ const BSTR strObjectPath,
+        /* [in] */ const BSTR strMethodName,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+
+};
+
+
+class CProviderHelper
+{   
+private:
+    CComPtr<IWbemClassObject> m_pErrorObject;
+    HRESULT m_hr; // store the construction status here
+
+public:
+    //Construction:
+    CProviderHelper(IWbemServices * pNamespace, IWbemContext *pCtx)
+    {
+        m_hr = WBEM_E_FAILED; // assume the worst to start
+        m_pErrorObject == NULL;
+        if (NULL == pNamespace)
+        {
+            m_hr = WBEM_E_INVALID_PARAMETER; 
+            ATLASSERT (0);
+            return;
+        }
+        BSTR bstrString = SysAllocString(L"__ExtendedStatus");
+        if (NULL == bstrString)
+        {
+            m_hr = WBEM_E_OUT_OF_MEMORY;
+            return;
+        }
+        m_hr = pNamespace->GetObject(bstrString, 
+                                     0, 
+                                     pCtx, 
+                                     &m_pErrorObject, 
+                                     NULL);
+        SysFreeString(bstrString);
+        return;
+    }
+
+    virtual ~CProviderHelper()
+    {
+    }   
+
+    HRESULT STDMETHODCALLTYPE ConstructErrorObject (
+                                                    /*in*/const ULONG ulStatusCode,
+                                                    /*in*/const BSTR bstrDescription,
+                                                    /*in*/const BSTR bstrOperation,
+                                                    /*in*/const BSTR bstrParameter,
+                                                    /*in*/const BSTR bstrProviderName,
+                                                    /*out*/IWbemClassObject ** ppErrorObject)
+    {
+
+        static const LPWSTR lpwstrDescription = L"Description";
+        static const LPWSTR lpwstrOperation = L"Operation";
+        static const LPWSTR lpwstrStatusCode = L"StatusCode";
+        static const LPWSTR lpwstrParameterInfo = L"ParameterInfo";
+        static const LPWSTR lpwstrProviderName = L"ProviderName";
+
+        if (FAILED (m_hr))
+        {
+            // constructor failed
+            ATLASSERT (0);
+            return m_hr;
+        }
+
+        if (NULL == ppErrorObject)
+        {
+            ATLASSERT (0);
+            return WBEM_E_INVALID_PARAMETER;
+        }
+
+        HRESULT hr = m_pErrorObject->SpawnInstance(0, ppErrorObject);
+        if(FAILED(hr))
+        {
+            return hr;
+        }
+
+        VARIANT var;
+        VariantInit(&var);
+        var.vt = VT_I4;
+        var.lVal = ulStatusCode;
+
+        hr = (*ppErrorObject)->Put(lpwstrStatusCode, 0, &var, 0);
+        if (FAILED(hr))
+        {
+            return hr;
+        }
+
+        var.vt = VT_BSTR;
+
+        if (bstrDescription != NULL)
+        {               
+            var.bstrVal = bstrDescription;
+            hr = (*ppErrorObject)->Put(lpwstrDescription, 0, &var, 0);
+            if (FAILED(hr))
+            {
+                return hr;
+            }
+        }
+        
+        if (bstrOperation != NULL)
+        {
+            var.bstrVal = bstrOperation;
+            hr = (*ppErrorObject)->Put(lpwstrOperation, 0, &var, 0);
+            if (FAILED(hr))
+            {
+                return hr;
+            }
+        }
+
+        if (bstrParameter != NULL)
+        {
+            var.bstrVal = bstrParameter;
+            hr = (*ppErrorObject)->Put(lpwstrParameterInfo, 0, &var, 0);
+            if (FAILED(hr))
+            {
+                return hr;
+            }
+        }
+
+        if (bstrProviderName != NULL)
+        {
+            var.bstrVal = bstrProviderName;
+            hr = (*ppErrorObject)->Put(lpwstrProviderName, 0, &var, 0);
+            if (FAILED(hr))
+            {
+                return hr;
+            }
+        }
+            
+        return hr;
+    }
+};
+
+class CIntrinsicEventProviderHelper : public CProviderHelper
+{
+private:
+    CComPtr<IWbemClassObject> m_pCreationEventClass;
+    CComPtr<IWbemClassObject> m_pDeletionEventClass;
+    CComPtr<IWbemClassObject> m_pModificationEventClass;
+    HRESULT m_hr;
+
+public:
+
+    //Construction
+    CIntrinsicEventProviderHelper( IWbemServices * pNamespace, IWbemContext * pCtx)
+                : CProviderHelper ( pNamespace, pCtx)
+    {
+        m_hr = WBEM_E_FAILED; // assume the worst
+
+        if (NULL == pNamespace || NULL == pCtx)
+        {
+            m_hr = WBEM_E_INVALID_PARAMETER;
+            ATLASSERT (0);
+            return;
+        }
+
+        m_pCreationEventClass = NULL;
+        m_pModificationEventClass = NULL; 
+        m_pDeletionEventClass = NULL;
+
+        BSTR bstrString = SysAllocString(L"__InstanceCreationEvent");
+        if (NULL == bstrString)
+        {
+            m_hr = WBEM_E_OUT_OF_MEMORY;
+            return;
+        }
+
+        m_hr = pNamespace->GetObject(bstrString, 
+                                     0, 
+                                     pCtx, 
+                                     &m_pCreationEventClass, 
+                                     NULL);
+        SysFreeString(bstrString);
+        bstrString=NULL;
+        if (FAILED(m_hr)) 
+        {
+            return;
+        }
+
+        bstrString = SysAllocString(L"__InstanceModificationEvent");
+        if (NULL == bstrString)
+        {
+            m_hr = WBEM_E_OUT_OF_MEMORY;
+            return;
+        }
+        m_hr = pNamespace->GetObject(bstrString, 
+                                     0, 
+                                     pCtx, //passing IWbemContext pointer to prevent deadlocks
+                                     &m_pModificationEventClass, 
+                                     NULL);
+        SysFreeString(bstrString);
+        bstrString=NULL;
+        if (FAILED(m_hr)) 
+        {
+            return;
+        }
+        
+        bstrString = SysAllocString(L"__InstanceDeletionEvent");
+        if (NULL == bstrString)
+        {
+            m_hr = WBEM_E_OUT_OF_MEMORY;
+            return;
+        }
+        m_hr = pNamespace->GetObject(bstrString, 
+                                     0, 
+                                     pCtx, //passing IWbemContext pointer to prevent deadlocks
+                                     &m_pDeletionEventClass, 
+                                     NULL);
+        SysFreeString(bstrString);
+        bstrString=NULL;           
+        if (FAILED(m_hr)) 
+        {
+            return;
+        }
+
+        return;
+    }
+
+    virtual ~CIntrinsicEventProviderHelper()
+    {
+    }
+
+    HRESULT STDMETHODCALLTYPE FireCreationEvent(
+                                                /*in*/IWbemClassObject * pNewInstance,
+                                                /*in*/IWbemObjectSink * pSink )
+    {
+        if (FAILED(m_hr))
+        {
+            // construction failed
+            ATLASSERT (0);      
+            return m_hr;
+        }
+
+        if (pNewInstance == NULL || pSink == NULL)
+        {
+            ATLASSERT (0);      
+            return WBEM_E_INVALID_PARAMETER;
+        }
+        
+        CComPtr<IWbemClassObject> pEvtInstance;
+        HRESULT hr = m_pCreationEventClass->SpawnInstance(0, &pEvtInstance);
+        if(FAILED(hr))
+        {
+            return hr;
+        }
+        
+        VARIANT var;
+        VariantInit(&var);
+        var.vt = VT_UNKNOWN; 
+        CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pNewInstance);
+        var.punkVal = pTemp;
+        hr = pEvtInstance->Put(L"TargetInstance", 0, &var, 0);
+        if(FAILED(hr))
+        {
+            return hr;
+        }
+
+        IWbemClassObject *_pEvtInstance = (IWbemClassObject*)pEvtInstance;
+        return pSink->Indicate(1, &_pEvtInstance);
+    }
+
+
+    HRESULT STDMETHODCALLTYPE FireDeletionEvent(
+                                    /*in*/IWbemClassObject * pInstanceToDelete,
+                                    /*in*/IWbemObjectSink * pSink )
+    {
+        if (FAILED (m_hr))
+        {
+            // construction failed
+            ATLASSERT (0);      
+            return m_hr;
+        }
+
+        if (pInstanceToDelete == NULL || pSink == NULL)
+        {
+            ATLASSERT (0);      
+            return WBEM_E_INVALID_PARAMETER;
+        }
+
+        CComPtr<IWbemClassObject> pEvtInstance;
+        HRESULT hr = m_pDeletionEventClass->SpawnInstance(0, &pEvtInstance);
+        if(FAILED(hr))
+        {
+            return hr;
+        }
+
+        VARIANT var;
+        VariantInit(&var);
+        var.vt = VT_UNKNOWN; 
+        CComQIPtr<IUnknown, &IID_IUnknown>pTemp(pInstanceToDelete);
+        var.punkVal = pTemp;
+        hr = pEvtInstance->Put(L"TargetInstance", 0, &var, 0);
+        if(FAILED(hr))
+        {
+            return hr;
+        }
+
+        IWbemClassObject *_pEvtInstance = (IWbemClassObject*)pEvtInstance;
+        return pSink->Indicate(1, &_pEvtInstance);
+    }
+
+
+    HRESULT STDMETHODCALLTYPE FireModificationEvent(
+                                                    /*in*/IWbemClassObject * pOldInstance,
+                                                    /*in*/IWbemClassObject * pNewInstance,
+                                                    /*in*/IWbemObjectSink * pSink )
+    {
+        if (FAILED (m_hr))
+        {
+            // construction failed
+            ATLASSERT (0);      
+            return m_hr;
+        }
+
+        if (pOldInstance == NULL || pNewInstance == NULL || pSink == NULL)
+        {
+            ATLASSERT (0);      
+            return WBEM_E_INVALID_PARAMETER;
+        }
+                
+        CComPtr<IWbemClassObject> pEvtInstance;
+        HRESULT hr = m_pModificationEventClass->SpawnInstance(0, &pEvtInstance);
+        if(FAILED(hr))
+        {
+            return hr;
+        }
+
+        VARIANT var;
+        VariantInit(&var);
+        var.vt = VT_UNKNOWN; 
+        CComQIPtr<IUnknown, &IID_IUnknown>pTempNew(pNewInstance);
+        var.punkVal = pTempNew;
+        hr = pEvtInstance->Put(L"TargetInstance", 0, &var, 0);
+        if (FAILED(hr)) 
+        {       
+            return hr;
+        }
+        
+        CComQIPtr<IUnknown, &IID_IUnknown>pTempOld(pOldInstance);
+        var.punkVal = pTempOld;
+        hr = pEvtInstance->Put(L"PreviousInstance", 0, &var, 0);
+        if (FAILED(hr)) 
+        {       
+            return hr;
+        }
+        
+        IWbemClassObject *_pEvtInstance = (IWbemClassObject*)pEvtInstance;
+        return pSink->Indicate(1, &_pEvtInstance);
+    }
+
+};
+
+class CInstanceProviderHelper : public CProviderHelper
+{
+
+public:
+
+    CInstanceProviderHelper (IWbemServices * pNamespace, IWbemContext *pCtx)
+                : CProviderHelper ( pNamespace, pCtx)
+    {
+    }
+
+    virtual ~CInstanceProviderHelper()
+    {
+    }
+    
+    HRESULT STDMETHODCALLTYPE CheckInstancePath (
+                                /*[in]*/ IClassFactory * pParserFactory,    //pointer to path parser class factory
+                                /*[in]*/ const BSTR ObjectPath, //object path string
+                                /*[in]*/ const BSTR ClassName,  //name of WMI class whose instances are provided
+                                /*[in]*/ ULONGLONG ullTest)          //flags from WMI_PATH_STATUS_FLAG (defined in wmiutils.h)
+    {   
+
+        if (pParserFactory == NULL)
+        {
+            ATLASSERT (0);      
+            return WBEM_E_INVALID_PARAMETER;
+        }
+        
+        //Create path parser object
+        CComPtr<IWbemPath>pPath;
+        HRESULT hr = pParserFactory->CreateInstance(NULL,
+                                            IID_IWbemPath,
+                                            (void **) &pPath);
+        if (FAILED(hr))
+        {
+            return WBEM_E_INVALID_PARAMETER;
+        }
+
+        hr = pPath->SetText(WBEMPATH_CREATE_ACCEPT_ALL,
+                                    ObjectPath);
+        if(FAILED(hr))
+        {
+            return hr;
+        }
+
+        //check that the class requested is the class provided
+        unsigned int nPathLen = SysStringLen(ObjectPath);  // assume this is a real BSTR not just WCHAR*
+        if (nPathLen >= (unsigned long)(-1)) return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);
+        
+        unsigned long ulBufLen = (unsigned long)(nPathLen + 1);
+        WCHAR * wClass = new WCHAR[ulBufLen];
+        if (NULL == wClass)
+        {
+            return WBEM_E_OUT_OF_MEMORY;
+        }
+        hr = pPath->GetClassName(&ulBufLen, wClass);
+        if(FAILED(hr))
+        {
+            delete[] wClass;
+            return hr;
+        }
+        DWORD lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);
+        if (CSTR_EQUAL != CompareStringW(lcid, NORM_IGNORECASE, ClassName, -1, wClass, -1))
+        {
+            delete[] wClass;
+            return WBEM_E_NOT_FOUND;
+        }
+        
+        delete[] wClass;
+        
+        //check that the path reflects the object type
+        unsigned __int64 ullPathInfo;
+        hr = pPath->GetInfo(0L, &ullPathInfo);
+        if(FAILED(hr))
+        {
+            return hr;
+        }
+
+        if (!(ullPathInfo & ullTest))
+        {
+            return WBEM_E_INVALID_OBJECT_PATH;
+        }   
+        
+        return WBEM_S_NO_ERROR;     
+    }
+
+};
+
+
+//IWbemPullClassProviderImpl class 
+
+template <class T>
+class ATL_NO_VTABLE IWbemPullClassProviderImpl : public IWbemServices,
+                                                 public IWbemProviderInit
+{
+public:
+
+
+    //IWbemServices  
+
+    virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
+        /* [in] */ const BSTR strNamespace,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult){return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
+        /* [in] */ IWbemObjectSink __RPC_FAR *pSink){return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
+        /* [in] */ long lFlags,
+        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE GetObject( 
+        /* [in] */ const BSTR strObjectPath,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
+    
+    
+    virtual HRESULT STDMETHODCALLTYPE PutClass( 
+        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
+    
+    
+    virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
+        /* [in] */ const BSTR strClass,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
+    
+    
+    virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
+        /* [in] */ const BSTR strSuperclass,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
+    
+    
+    virtual HRESULT STDMETHODCALLTYPE PutInstance( 
+        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
+        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
+        /* [in] */ const BSTR strObjectPath,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult){return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
+        /* [in] */ const BSTR strObjectPath,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler){return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
+        /* [in] */ const BSTR strClass,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
+        /* [in] */ const BSTR strClass,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
+        /* [in] */ const BSTR strQueryLanguage,
+        /* [in] */ const BSTR strQuery,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
+    
+    
+    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
+        /* [in] */ const BSTR strQueryLanguage,
+        /* [in] */ const BSTR strQuery,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) {return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
+        /* [in] */ const BSTR strQueryLanguage,
+        /* [in] */ const BSTR strQuery,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
+        /* [in] */ const BSTR strObjectPath,
+        /* [in] */ const BSTR strMethodName,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
+        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
+        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) {return WBEM_E_NOT_SUPPORTED;};
+    
+    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
+        /* [in] */ const BSTR strObjectPath,
+        /* [in] */ const BSTR strMethodName,
+        /* [in] */ long lFlags,
+        /* [in] */ IWbemContext __RPC_FAR *pCtx,
+        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
+        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) {return WBEM_E_NOT_SUPPORTED;};
+    
+
+};
+
+class CImpersonateClientHelper
+{
+    private:
+        BOOL m_bImpersonate;    
+    public:
+        CImpersonateClientHelper()
+        { 
+            m_bImpersonate = FALSE;
+        }
+
+        ~CImpersonateClientHelper()
+        {
+            if(m_bImpersonate)
+                CoRevertToSelf();
+        }
+
+        HRESULT ImpersonateClient()
+        {
+            HRESULT hr = S_OK;
+            if(SUCCEEDED(hr = CoImpersonateClient()))
+            {
+                m_bImpersonate = TRUE;
+            }
+            return hr;
+        }
+
+        HRESULT GetCurrentImpersonationLevel ( DWORD & a_Level )
+        {
+            DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
+            HANDLE t_ThreadToken = NULL ;
+            
+            HRESULT t_Result = S_OK ;
+            if(SUCCEEDED(t_Result = CoImpersonateClient()))
+            {
+                BOOL t_Status = OpenThreadToken (GetCurrentThread() ,TOKEN_QUERY,TRUE,&t_ThreadToken);
+                if ( t_Status )
+                {
+                    SECURITY_IMPERSONATION_LEVEL t_Level = SecurityAnonymous ;
+                    DWORD t_Returned = 0 ;
+         
+                    t_Status = GetTokenInformation (t_ThreadToken ,TokenImpersonationLevel ,&t_Level ,sizeof(SECURITY_IMPERSONATION_LEVEL),&t_Returned);
+                    CloseHandle ( t_ThreadToken ) ;
+
+                    if ( t_Status == FALSE )
+                    {
+                        t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError());
+                    }
+                    else
+                    {
+                        switch ( t_Level )
+                        {
+                            case SecurityAnonymous:
+                            {
+                                t_ImpersonationLevel = RPC_C_IMP_LEVEL_ANONYMOUS ;
+                            }
+                            break ;
+
+                            case SecurityIdentification:
+                            {
+                                t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTIFY ;
+                            }
+                            break ;
+
+                            case SecurityImpersonation:
+                            {
+                                t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
+                            }
+                            break ;
+
+                            case SecurityDelegation:
+                            {
+                                t_ImpersonationLevel = RPC_C_IMP_LEVEL_DELEGATE ;
+                            }
+                            break ;
+
+                            default:
+                            {
+                                t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,E_UNEXPECTED);
+                            }
+                            break ;
+                        }
+                    }
+                }
+                else
+                {
+                    t_Result = MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,GetLastError());
+                }
+
+                CoRevertToSelf();
+            }
+
+            a_Level = t_ImpersonationLevel ;
+            return t_Result ; 
+        }
+
+    };
+}       //namespace ATL
+
+#endif  //__ATLWMIPROV_H__
diff --git a/include/xutility b/include/xutility
index 2c1c8b6..bf3086e 100644
--- a/include/xutility
+++ b/include/xutility
@@ -119,8 +119,15 @@ public:
 
 	_Iterator_base12& operator=(const _Iterator_base12& _Right)
 		{	// assign an iterator
-		if (_Myproxy != _Right._Myproxy)
+		if (_Myproxy == _Right._Myproxy)
+			;
+		else if (_Right._Myproxy != 0)
 			_Adopt(_Right._Myproxy->_Mycont);
+		else
+			{	// becoming invalid, disown current parent
+			_Lockit _Lock(_LOCK_DEBUG);
+			_Orphan_me();
+			}
 		return (*this);
 		}
 
@@ -134,7 +141,12 @@ public:
 
 	void _Adopt(const _Container_base12 *_Parent)
 		{	// adopt this iterator by parent
-		if (_Parent != 0)
+		if (_Parent == 0)
+			{	// no future parent, just disown current parent
+			_Lockit _Lock(_LOCK_DEBUG);
+			_Orphan_me();
+			}
+		else
 			{	// have a parent, do adoption
 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
 
-- 
2.17.0.gvfs.1.preview.6

